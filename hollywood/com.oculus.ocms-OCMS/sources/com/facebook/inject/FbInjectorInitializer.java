package com.facebook.inject;

import com.facebook.debug.tracer.Tracer;
import com.facebook.inject.testing.OverridesBindings;
import com.facebook.ultralight.UL;
import com.google.common.base.Throwables;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import com.google.inject.Key;
import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.inject.Provider;

/* access modifiers changed from: package-private */
public class FbInjectorInitializer {
    private final Map<Integer, Binding> mBindingMap;
    private final Map<Key, ComponentBinding> mComponentBindingMap;
    private final FbInjector mFbInjector;
    private final boolean mIsDebugMode;
    private final List<? extends PrivateModule> mModules;
    private final Set<Class<?>> mModulesInstalled;
    private final Map<Key, MultiBinder> mMultiBindings;
    private final Map<Class<? extends Annotation>, Scope> mScopeMap;

    public FbInjectorInitializer(FbInjector fbInjector, List<? extends PrivateModule> list, boolean z) {
        this.mBindingMap = Maps.newHashMap();
        this.mComponentBindingMap = Maps.newHashMap();
        this.mModulesInstalled = new HashSet();
        this.mScopeMap = Maps.newLinkedHashMap();
        this.mMultiBindings = Maps.newHashMap();
        this.mFbInjector = fbInjector;
        this.mModules = list;
        this.mIsDebugMode = z;
    }

    public FbInjectorInitializer(FbInjector fbInjector, List<? extends PrivateModule> list, boolean z, Map<Integer, Binding> map, Map<Class<? extends Annotation>, Scope> map2, Map<Key, ComponentBinding> map3, Set<Class<?>> set, Map<Key, MultiBinder> map4) {
        this(fbInjector, list, z);
        this.mBindingMap.putAll(map);
        this.mComponentBindingMap.putAll(map3);
        this.mScopeMap.putAll(map2);
        this.mModulesInstalled.addAll(set);
        this.mMultiBindings.putAll(map4);
    }

    /* access modifiers changed from: package-private */
    public static class Result {
        final Map<Integer, Binding> bindingMap;
        final Map<Key, ComponentBinding> componentBindingMap;
        final Set<Class<?>> modulesInstalled;
        final Map<Key, MultiBinder> multiBindings;
        final Map<Class<? extends Annotation>, Scope> scopeMap;

        Result(Map<Integer, Binding> map, Map<Class<? extends Annotation>, Scope> map2, Map<Key, ComponentBinding> map3, Set<Class<?>> set, Map<Key, MultiBinder> map4) {
            this.bindingMap = map;
            this.scopeMap = map2;
            this.componentBindingMap = map3;
            this.modulesInstalled = set;
            this.multiBindings = map4;
        }
    }

    public Result init() {
        return runInit(false);
    }

    public Result update() {
        return runInit(true);
    }

    private Result runInit(boolean z) {
        Tracer.startTracer("FbInjectorImpl.init#modules");
        if (!z) {
            try {
                installSpecialModule(new UL.InitModule());
            } catch (Throwable th) {
                Tracer.stopTracer();
                throw th;
            }
        }
        if (!UL.USE_STATIC_DI) {
            for (PrivateModule privateModule : this.mModules) {
                this.mModulesInstalled.add(privateModule.getClass());
                installPrivateModule(privateModule);
            }
        }
        Tracer.stopTracer();
        if (!UL.USE_STATIC_DI) {
            initializeMultiBindings();
        }
        return new Result(this.mBindingMap, this.mScopeMap, this.mComponentBindingMap, this.mModulesInstalled, this.mMultiBindings);
    }

    private void installSpecialModule(SpecialModule specialModule) {
        BinderImpl binderImpl = new BinderImpl(this.mFbInjector, specialModule.getClass());
        specialModule.configure(binderImpl);
        installModule(binderImpl, specialModule.getClass());
        this.mModulesInstalled.add(specialModule.getClass());
    }

    private void installLegacyModule(Class<?> cls) {
        BinderImpl binderImpl = new BinderImpl(this.mFbInjector, cls);
        if (OverridesBindings.class.isAssignableFrom(cls) || (cls.getAnnotation(InjectorModule.class) == null && cls.getAnnotation(GeneratedInjectorModule.class) == null)) {
            invokeConfigure(newInstanceOfModule(cls), binderImpl);
        } else {
            invokeAutoGeneratedBindings(cls, binderImpl);
        }
        installModule(binderImpl, cls);
    }

    private void installPrivateModule(PrivateModule privateModule) {
        BinderImpl binderImpl = new BinderImpl(this.mFbInjector, privateModule.getClass());
        invokeConfigure(privateModule, binderImpl);
        installModule(binderImpl, privateModule.getClass());
    }

    private void invokeAutoGeneratedBindings(Class cls, Binder binder) {
        try {
            Method declaredMethod = Class.forName(cls.getName() + "$AutoGeneratedBindingsFor" + cls.getSimpleName()).getDeclaredMethod("bind", Binder.class);
            declaredMethod.setAccessible(true);
            declaredMethod.invoke(null, binder);
        } catch (NoSuchMethodException e) {
            throw Throwables.propagate(e);
        } catch (IllegalAccessException e2) {
            throw Throwables.propagate(e2);
        } catch (InvocationTargetException e3) {
            Throwables.propagateIfInstanceOf(e3.getCause(), RuntimeException.class);
        } catch (ClassNotFoundException e4) {
            throw Throwables.propagate(e4);
        }
    }

    private void invokeConfigure(Object obj, Binder binder) {
        try {
            Field declaredField = AbstractModule.class.getDeclaredField("mBinder");
            declaredField.setAccessible(true);
            declaredField.set(obj, binder);
            Method declaredMethod = obj.getClass().getDeclaredMethod("configure", new Class[0]);
            declaredMethod.setAccessible(true);
            declaredMethod.invoke(obj, new Object[0]);
        } catch (NoSuchFieldException | NoSuchMethodException unused) {
        } catch (IllegalAccessException e) {
            throw Throwables.propagate(e);
        } catch (InvocationTargetException e2) {
            Throwables.propagateIfInstanceOf(e2.getCause(), RuntimeException.class);
        }
    }

    private void installModule(Binder binder, Class<?> cls) {
        this.mScopeMap.putAll(binder.getScopes());
        for (Class<?> cls2 : binder.getRequiredModules()) {
            if (!this.mModulesInstalled.contains(cls2)) {
                this.mModulesInstalled.add(cls2);
                installLegacyModule(cls2);
            }
        }
        for (Binding binding : binder.getBindings()) {
            addSingleBinding(this.mFbInjector, cls, binding, binder.getRequiredModules());
        }
        if (!UL.USE_STATIC_DI) {
            for (Scope scope : binder.getScopes().values()) {
                Binding binding2 = new Binding();
                binding2.setModule(cls.getClass());
                binding2.setKey(Key.get((Class) scope.getClass()));
                binding2.setProvider(new InstanceProvider(scope));
                addSingleBinding(this.mFbInjector, cls, binding2, binder.getRequiredModules());
            }
        }
        for (ComponentBinding componentBinding : binder.getComponentBindings()) {
            ComponentProvider provider = componentBinding.getProvider();
            if (provider instanceof ComponentProviderWithInjector) {
                ((ComponentProviderWithInjector) provider).setInjector(this.mFbInjector);
            }
            this.mComponentBindingMap.put(componentBinding.getKey(), componentBinding);
        }
        for (Key key : Sets.union(binder.getMultiBindingDeclarations(), binder.getMultiBindings().keySet())) {
            if (this.mMultiBindings.get(key) == null) {
                this.mMultiBindings.put(key, new MultiBinder(this.mFbInjector, key));
            }
        }
        for (Map.Entry<Key, MultiBinding> entry : binder.getMultiBindings().entrySet()) {
            this.mMultiBindings.get(entry.getKey()).addAll(entry.getValue().getValues());
        }
    }

    /* JADX DEBUG: Multi-variable search result rejected for r14v0, resolved type: com.facebook.inject.Binding<T> */
    /* JADX WARN: Multi-variable type inference failed */
    private <T> void addSingleBinding(FbInjector fbInjector, Class<?> cls, Binding<T> binding, List<Class<?>> list) {
        Key<T> key = binding.getKey();
        int dynamicId = UL.id.dynamicId(key);
        Provider<T> provider = binding.getProvider();
        binding.setOriginalProvider(provider);
        Binding binding2 = this.mBindingMap.get(Integer.valueOf(dynamicId));
        if (binding2 == null || !canOverrideBindings(binding2.getDeclaringModule()) || canOverrideBindings(cls)) {
            if (binding2 != null && !canOverrideBindings(cls)) {
                if (!binding2.isDefaultBinding()) {
                    throw new IllegalArgumentException(String.format("Module %s illegally overriding binding for %s from module %s. Either require module %s(base module) from %s or provide %s as a default binding so it can be overridden in module %s(top module) .", binding.getDeclaringModule().getCanonicalName(), binding2.getKey().toString(), binding2.getDeclaringModule().getCanonicalName(), binding2.getDeclaringModule().getCanonicalName(), binding.getDeclaringModule().getCanonicalName(), binding2.getKey().toString(), binding.getDeclaringModule().getCanonicalName()));
                } else if (!binding2.isDefaultBinding() && !binding2.getDeclaringModule().equals(binding.getDeclaringModule()) && !list.contains(binding2.getDeclaringModule())) {
                    throw new IllegalArgumentException(String.format("Module %s is overriding binding for %s from module %s, but does not require that module. Add %s(base module) in the dependency list of %s.", binding.getDeclaringModule().getCanonicalName(), binding2.getKey().toString(), binding2.getDeclaringModule().getCanonicalName(), binding2.getDeclaringModule().getCanonicalName(), binding.getDeclaringModule().getCanonicalName()));
                }
            }
            if (provider instanceof ProviderWithInjector) {
                ((ProviderWithInjector) provider).setInjector(fbInjector);
            }
            if (binding.getScope() != null) {
                provider = getScope(binding.getScope()).scope(key, provider);
                if (provider instanceof ProviderWithInjector) {
                    ((ProviderWithInjector) provider).setInjector(fbInjector);
                }
            }
            binding.setProvider(provider);
            this.mBindingMap.put(Integer.valueOf(dynamicId), binding);
        }
    }

    private Object newInstanceOfModule(Class<?> cls) {
        try {
            Constructor<?> constructor = cls.getConstructor(new Class[0]);
            constructor.setAccessible(true);
            return constructor.newInstance(new Object[0]);
        } catch (NoSuchMethodException e) {
            throw new RuntimeException("Failed to find public default constructor for " + cls, e);
        } catch (InvocationTargetException e2) {
            throw new RuntimeException("Failed to invoke constructor for " + cls, e2);
        } catch (InstantiationException e3) {
            throw new RuntimeException("Failed to instantiate " + cls, e3);
        } catch (IllegalAccessException e4) {
            throw new RuntimeException("Failed to access constructor for " + cls, e4);
        }
    }

    private void initializeMultiBindings() {
        Tracer.startTracer("FbInjectorImpl.init#multiBinding");
        try {
            for (MultiBinder multiBinder : this.mMultiBindings.values()) {
                Binding binding = new Binding();
                binding.setKey(multiBinder.getBoundKey());
                binding.setProvider(multiBinder.getProvider());
                binding.setOriginalProvider(multiBinder.getProvider());
                this.mBindingMap.put(Integer.valueOf(UL.id.dynamicId(multiBinder.getBoundKey())), binding);
            }
        } finally {
            Tracer.stopTracer();
        }
    }

    private Scope getScope(Class<? extends Annotation> cls) {
        Scope scope = this.mScopeMap.get(cls);
        if (scope != null) {
            return scope;
        }
        throw new ProvisioningException("No scope registered for " + cls);
    }

    private static boolean canOverrideBindings(Class<?> cls) {
        return OverridesBindings.class.isAssignableFrom(cls) || UL.InitModule.class.isAssignableFrom(cls);
    }
}
