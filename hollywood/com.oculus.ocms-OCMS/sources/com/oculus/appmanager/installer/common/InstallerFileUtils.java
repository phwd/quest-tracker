package com.oculus.appmanager.installer.common;

import android.content.Context;
import android.content.pm.PackageManager;
import android.os.Build;
import android.os.Environment;
import android.text.TextUtils;
import androidx.annotation.VisibleForTesting;
import com.facebook.common.android.AndroidModule;
import com.facebook.common.stringformat.StringFormatUtil;
import com.facebook.debug.log.BLog;
import com.facebook.inject.BundledAndroidModule;
import com.facebook.inject.FbInjector;
import com.facebook.inject.InjectionContext;
import com.facebook.inject.InjectorLike;
import com.facebook.inject.Lazy;
import com.facebook.inject.UltralightLazy;
import com.facebook.inject.UltralightProvider;
import com.facebook.ultralight.AutoGeneratedAccessMethod;
import com.facebook.ultralight.AutoGeneratedFactoryMethod;
import com.facebook.ultralight.Dependencies;
import com.facebook.ultralight.Inject;
import com.facebook.ultralight.UL;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.io.Files;
import com.oculus.appmanager.info.ApkUpdateInfo;
import com.oculus.appmanager.info.ApkUpdateInfoContract;
import com.oculus.appmanager.installer.analytics.AnalyticsModule;
import com.oculus.appmanager.installer.analytics.InstallerAnalytics;
import com.oculus.appmanager.installer.common.CommonModule;
import com.oculus.appmanager.patcher.Patcher;
import com.oculus.downloader.contract.DownloaderContract;
import com.oculus.library.database.contract.LibraryDBContract;
import com.oculus.time.Clock;
import com.oculus.time.TimeModule;
import java.io.File;
import java.io.IOException;
import java.util.Locale;
import javax.annotation.Nullable;
import javax.inject.Provider;

@Dependencies({"_UL__ULSEP_android_content_Context_ULSEP_com_facebook_inject_ForAppContext_ULSEP_BINDING_ID", "_UL__ULSEP_android_content_pm_PackageManager_ULSEP_BINDING_ID", "_UL__ULSEP_com_oculus_appmanager_patcher_Patcher_ULSEP_BINDING_ID", "_UL__ULSEP_com_oculus_appmanager_info_InfoUtils_ULSEP_BINDING_ID", "_UL__ULSEP_com_oculus_appmanager_installer_common_CryptoMethods_ULSEP_BINDING_ID", "_UL__ULSEP_com_oculus_appmanager_installer_analytics_InstallerAnalytics_ULSEP_BINDING_ID", "_UL__ULSEP_com_oculus_time_Clock_ULSEP_BINDING_ID"})
public class InstallerFileUtils {
    private static final String APK_FOLDER = "apk_to_install";
    public static final String APK_PATCH_SUFFIX = ".apkpatch";
    public static final String APK_SUFFIX = ".apk";
    public static final String ASSET_PATCH_SUFFIX = ".assetpatch";
    public static final String ASSET_SUFFIX = ".asset";
    public static final String DOWNLOADING_APK_PATCH_SUFFIX = ".apk_patch_downloading";
    public static final String DOWNLOADING_APK_SUFFIX = ".apk_downloading";
    public static final String DOWNLOADING_ASSET_PATCH_SUFFIX = ".asset_patch_downloading";
    public static final String DOWNLOADING_ASSET_SUFFIX = ".asset_downloading";
    public static final String DOWNLOADING_OBB_PATCH_SUFFIX = ".obb_patch_downloading";
    public static final String DOWNLOADING_OBB_SUFFIX = ".obb_downloading";
    public static final String FILENAME_BACKUP_FORMAT = "%s.backup.%s.%s.tmp";
    public static final String FILENAME_OBB_FORMAT = "main.%s.%s.obb";
    public static final String FILENAME_PREP_FORMAT = "%s.prep.%s.tmp";
    public static final String FILE_PATH_OBB_ASSET_FORMAT_STRING = "%s/Android/obb/%s/%s";
    public static final String OBB_PATCH_SUFFIX = ".obbpatch";
    public static final String OBB_SUFFIX = ".obb";
    private static final String TAG = "InstallerFileUtils";
    private static final String UNIQUE_NAME_FORMAT_STRING = "%d.%s%s";
    public static final long UNKNOWN_FILE_SIZE = -1;
    private InjectionContext _UL_mInjectionContext;
    @Inject
    private final Lazy<Patcher> mPatcherLazy;

    @AutoGeneratedAccessMethod
    public static final Lazy _UL__ULSEP_com_facebook_inject_Lazy_ULLT_com_oculus_appmanager_installer_common_InstallerFileUtils_ULGT__ULSEP_ACCESS_METHOD(InjectorLike injectorLike) {
        return UltralightLazy.get(CommonModule.UL_id._UL__ULSEP_com_oculus_appmanager_installer_common_InstallerFileUtils_ULSEP_BINDING_ID, injectorLike);
    }

    @AutoGeneratedAccessMethod
    public static final InstallerFileUtils _UL__ULSEP_com_oculus_appmanager_installer_common_InstallerFileUtils_ULSEP_ACCESS_METHOD(InjectorLike injectorLike) {
        return (InstallerFileUtils) UL.factorymap.get(CommonModule.UL_id._UL__ULSEP_com_oculus_appmanager_installer_common_InstallerFileUtils_ULSEP_BINDING_ID, injectorLike);
    }

    @AutoGeneratedFactoryMethod
    public static final InstallerFileUtils _UL__ULSEP_com_oculus_appmanager_installer_common_InstallerFileUtils_ULSEP_FACTORY_METHOD(InjectorLike injectorLike) {
        return new InstallerFileUtils(injectorLike);
    }

    @AutoGeneratedAccessMethod
    public static final Provider _UL__ULSEP_javax_inject_Provider_ULLT_com_oculus_appmanager_installer_common_InstallerFileUtils_ULGT__ULSEP_ACCESS_METHOD(InjectorLike injectorLike) {
        return UltralightProvider.get(CommonModule.UL_id._UL__ULSEP_com_oculus_appmanager_installer_common_InstallerFileUtils_ULSEP_BINDING_ID, injectorLike);
    }

    @Inject
    public InstallerFileUtils(InjectorLike injectorLike) {
        this._UL_mInjectionContext = new InjectionContext(6, injectorLike);
        this.mPatcherLazy = Patcher._UL__ULSEP_com_facebook_inject_Lazy_ULLT_com_oculus_appmanager_patcher_Patcher_ULGT__ULSEP_ACCESS_METHOD(injectorLike);
    }

    private String getUniqueFileName(ApkUpdateInfo apkUpdateInfo, String str) {
        return StringFormatUtil.formatStrLocaleSafe(UNIQUE_NAME_FORMAT_STRING, Long.valueOf(apkUpdateInfo.id), apkUpdateInfo.identifier, str);
    }

    private String getDownloadingFileName(ApkUpdateInfo apkUpdateInfo) {
        switch (apkUpdateInfo.updateType) {
            case STORE_FULL_APK:
            case DIRECT_APK:
                return getUniqueFileName(apkUpdateInfo, DOWNLOADING_APK_SUFFIX);
            case STORE_PATCH_APK:
                return getUniqueFileName(apkUpdateInfo, DOWNLOADING_APK_PATCH_SUFFIX);
            case STORE_FULL_OBB:
            case DIRECT_OBB:
                return getUniqueFileName(apkUpdateInfo, DOWNLOADING_OBB_SUFFIX);
            case STORE_PATCH_OBB:
                return getUniqueFileName(apkUpdateInfo, DOWNLOADING_OBB_PATCH_SUFFIX);
            case STORE_FULL_ASSET:
            case DIRECT_ASSET:
                return getUniqueFileName(apkUpdateInfo, DOWNLOADING_ASSET_SUFFIX);
            case STORE_PATCH_ASSET:
                return getUniqueFileName(apkUpdateInfo, DOWNLOADING_ASSET_PATCH_SUFFIX);
            default:
                throw new IllegalArgumentException("Invalid update type supplied: " + apkUpdateInfo.updateType.name());
        }
    }

    private String getDownloadedFileName(ApkUpdateInfo apkUpdateInfo) {
        switch (apkUpdateInfo.updateType) {
            case STORE_FULL_APK:
            case DIRECT_APK:
                return getUniqueFileName(apkUpdateInfo, APK_SUFFIX);
            case STORE_PATCH_APK:
                return getUniqueFileName(apkUpdateInfo, APK_PATCH_SUFFIX);
            case STORE_FULL_OBB:
            case DIRECT_OBB:
                return getUniqueFileName(apkUpdateInfo, OBB_SUFFIX);
            case STORE_PATCH_OBB:
                return getUniqueFileName(apkUpdateInfo, OBB_PATCH_SUFFIX);
            case STORE_FULL_ASSET:
            case DIRECT_ASSET:
                return getUniqueFileName(apkUpdateInfo, ASSET_SUFFIX);
            case STORE_PATCH_ASSET:
                return getUniqueFileName(apkUpdateInfo, ASSET_PATCH_SUFFIX);
            default:
                throw new IllegalArgumentException("Invalid update type supplied: " + apkUpdateInfo.updateType.name());
        }
    }

    private String getPatchedFileName(ApkUpdateInfo apkUpdateInfo) {
        if (apkUpdateInfo.updateType.isApk()) {
            return getUniqueFileName(apkUpdateInfo, APK_SUFFIX);
        }
        if (apkUpdateInfo.updateType.isObb()) {
            return getUniqueFileName(apkUpdateInfo, OBB_SUFFIX);
        }
        if (apkUpdateInfo.updateType.isAsset()) {
            return getUniqueFileName(apkUpdateInfo, ASSET_SUFFIX);
        }
        throw new IllegalArgumentException("Invalid update type supplied: " + apkUpdateInfo.updateType.name());
    }

    private String getSandboxedFileName(ApkUpdateInfo apkUpdateInfo) {
        if (apkUpdateInfo.updateType.isApk()) {
            return getUniqueFileName(apkUpdateInfo, APK_SUFFIX);
        }
        throw new IllegalArgumentException("Invalid update type supplied: " + apkUpdateInfo.updateType.name());
    }

    private File getDownloadingFile(ApkUpdateInfo apkUpdateInfo) {
        return new File(DownloaderContract.EXTERNAL_DOWNLOAD_SUB_DIRECTORY, getDownloadingFileName(apkUpdateInfo));
    }

    /* access modifiers changed from: package-private */
    @VisibleForTesting
    public File getDownloadedFile(ApkUpdateInfo apkUpdateInfo) {
        return new File(DownloaderContract.EXTERNAL_DOWNLOAD_SUB_DIRECTORY, getDownloadedFileName(apkUpdateInfo));
    }

    private File getPatchedFile(ApkUpdateInfo apkUpdateInfo) {
        return new File(DownloaderContract.EXTERNAL_DOWNLOAD_SUB_DIRECTORY, getPatchedFileName(apkUpdateInfo));
    }

    public File getExternalStorageFilesFolder() {
        return new File(DownloaderContract.EXTERNAL_DOWNLOAD_SUB_DIRECTORY);
    }

    public File getInternalStorageFilesFolder() {
        return new File(((Context) FbInjector.lazyInstance(0, BundledAndroidModule.UL_id._UL__ULSEP_android_content_Context_ULSEP_com_facebook_inject_ForAppContext_ULSEP_BINDING_ID, this._UL_mInjectionContext)).getFilesDir(), APK_FOLDER);
    }

    public File getLegacyInternalStorageFilesFolder() {
        return ((Context) FbInjector.lazyInstance(0, BundledAndroidModule.UL_id._UL__ULSEP_android_content_Context_ULSEP_com_facebook_inject_ForAppContext_ULSEP_BINDING_ID, this._UL_mInjectionContext)).getApplicationContext().getDir(APK_FOLDER, 0);
    }

    private File getSandboxedPath(ApkUpdateInfo apkUpdateInfo) {
        return new File(getInternalStorageFilesFolder(), getSandboxedFileName(apkUpdateInfo));
    }

    private String getObbFileName(ApkUpdateInfo apkUpdateInfo) {
        Preconditions.checkArgument(!TextUtils.isEmpty(apkUpdateInfo.getPackageName()));
        return getObbFileName(apkUpdateInfo.getPackageName(), apkUpdateInfo.targetVersion);
    }

    private String getObbFileName(String str, long j) {
        return StringFormatUtil.formatStrLocaleSafe(FILENAME_OBB_FORMAT, Long.valueOf(j), str);
    }

    public String getFinalObbPath(ApkUpdateInfo apkUpdateInfo) {
        Preconditions.checkArgument(!TextUtils.isEmpty(apkUpdateInfo.getPackageName()));
        long j = apkUpdateInfo.targetVersion;
        if (j == LibraryDBContract.VERSION_NOT_INSTALLED) {
            Preconditions.checkArgument(apkUpdateInfo.getExtras().hasKey(ApkUpdateInfoContract.EXTRA_PARSED_VERSION_CODE));
            j = apkUpdateInfo.getExtras().getParsedVersionCode();
        }
        return getFinalObbPath(apkUpdateInfo.getPackageName(), j);
    }

    public String getInstallationPreparationPath(ApkUpdateInfo apkUpdateInfo) {
        Preconditions.checkArgument(!TextUtils.isEmpty(apkUpdateInfo.getPackageName()));
        return StringFormatUtil.formatStrLocaleSafe(FILE_PATH_OBB_ASSET_FORMAT_STRING, Environment.getExternalStorageDirectory(), apkUpdateInfo.getPackageName(), StringFormatUtil.formatStrLocaleSafe(FILENAME_PREP_FORMAT, Long.valueOf(apkUpdateInfo.id), apkUpdateInfo.identifier));
    }

    public String getAssetBackupPath(ApkUpdateInfo apkUpdateInfo) {
        String formatStrLocaleSafe = StringFormatUtil.formatStrLocaleSafe(FILENAME_BACKUP_FORMAT, Long.valueOf(apkUpdateInfo.id), apkUpdateInfo.identifier, apkUpdateInfo.getExtras().getAssetRequiredFilename());
        Preconditions.checkArgument(!TextUtils.isEmpty(apkUpdateInfo.getPackageName()));
        return StringFormatUtil.formatStrLocaleSafe(FILE_PATH_OBB_ASSET_FORMAT_STRING, Environment.getExternalStorageDirectory(), apkUpdateInfo.getPackageName(), formatStrLocaleSafe);
    }

    public String getFinalObbPath(String str, long j) {
        return StringFormatUtil.formatStrLocaleSafe(FILE_PATH_OBB_ASSET_FORMAT_STRING, Environment.getExternalStorageDirectory(), str, getObbFileName(str, j));
    }

    public String getFinalAssetPath(ApkUpdateInfo apkUpdateInfo) {
        Preconditions.checkArgument(!TextUtils.isEmpty(apkUpdateInfo.getPackageName()));
        return getFinalAssetPath(apkUpdateInfo.getPackageName(), apkUpdateInfo.getExtras().getAssetRequiredFilename());
    }

    public static String getFinalAssetPath(String str, String str2) {
        return String.format(Locale.US, FILE_PATH_OBB_ASSET_FORMAT_STRING, Environment.getExternalStorageDirectory(), str, str2);
    }

    private void ensureFileExistsOrThrow(String str) throws IOException {
        ensureFileExistsOrThrow(new File(str));
    }

    private void ensureFileExistsOrThrow(File file) throws IOException {
        if (!file.exists()) {
            throw new IOException("File expected to exist: " + file.getCanonicalPath());
        }
    }

    public String move(String str, String str2) throws IOException {
        return move(new File(str), new File(str2));
    }

    public String move(File file, File file2) throws IOException {
        ensureFileExistsOrThrow(file);
        if (file2.exists()) {
            deleteIfExistsOrThrow(file2, "Clearing reserved spot for move operation");
        }
        File parentFile = file2.getParentFile();
        if (parentFile.mkdirs() || parentFile.exists()) {
            Files.move(file, file2);
            ensureFileExistsOrThrow(file2);
            return file2.getAbsolutePath();
        }
        throw new IOException("Unable to create directories for file move: " + parentFile.getCanonicalPath());
    }

    private void deleteIfExistsOrThrow(String str, String str2) throws IOException {
        deleteIfExistsOrThrow(new File(str), str2);
    }

    private void deleteIfExistsOrThrow(File file, String str) throws IOException {
        if (file.exists() && !removeFileWithReason(file, str)) {
            throw new IOException("Unable to delete file: " + file.getCanonicalPath());
        }
    }

    public boolean isAssetInstalled(ApkUpdateInfo apkUpdateInfo) {
        Preconditions.checkArgument(!TextUtils.isEmpty(apkUpdateInfo.getPackageName()));
        return isAssetInstalled(apkUpdateInfo.getPackageName(), apkUpdateInfo.getExtras().getAssetRequiredFilename());
    }

    public boolean isAssetInstalled(String str, String str2) {
        return new File(getFinalAssetPath(str, str2)).exists();
    }

    public boolean removeDirectoryWithReason(File file, String str) {
        Optional<Boolean> optional;
        if (!file.exists() || file.isDirectory()) {
            optional = performDelete(file);
        } else {
            String str2 = TAG;
            BLog.w(str2, "not a directory: " + file.getAbsolutePath());
            optional = Optional.of(false);
        }
        BLog.d(TAG, "Attempted to remove directory %s for reason \"%s\", removed = %s", file, str, optional.isPresent() ? optional.get() : "not found");
        if (optional.isPresent()) {
            return optional.get().booleanValue();
        }
        return false;
    }

    private boolean removeFileWithReason(File file, String str) {
        Optional<Boolean> optional;
        if (!file.exists() || file.isFile()) {
            optional = performDelete(file);
        } else {
            String str2 = TAG;
            BLog.w(str2, "not a file: " + file.getAbsolutePath());
            optional = Optional.of(false);
        }
        BLog.i(TAG, "Attempted to remove file %s for reason \"%s\", removed = %s", file, str, optional.isPresent() ? optional.get() : "not found");
        if (optional.isPresent()) {
            return optional.get().booleanValue();
        }
        return false;
    }

    private Optional<Boolean> performDelete(File file) {
        Optional<Boolean> absent = Optional.absent();
        if (Build.VERSION.SDK_INT <= 26) {
            return file.exists() ? Optional.of(Boolean.valueOf(file.delete())) : absent;
        }
        try {
            if (java.nio.file.Files.deleteIfExists(file.toPath())) {
                return Optional.of(true);
            }
            return absent;
        } catch (IOException | SecurityException e) {
            ((InstallerAnalytics) FbInjector.lazyInstance(4, AnalyticsModule.UL_id._UL__ULSEP_com_oculus_appmanager_installer_analytics_InstallerAnalytics_ULSEP_BINDING_ID, this._UL_mInjectionContext)).reportDeleteFailed(file, e);
            return Optional.of(false);
        }
    }

    public String getDownloadingFilename(ApkUpdateInfo apkUpdateInfo) {
        return getDownloadingFileName(apkUpdateInfo);
    }

    public String moveToDownloadedLocation(ApkUpdateInfo apkUpdateInfo) throws IOException {
        Preconditions.checkArgument(apkUpdateInfo.getExtras().hasKey(ApkUpdateInfoContract.EXTRA_DOWNLOADING_EXTERNAL_FILE));
        return move(new File(apkUpdateInfo.getExtras().getDownloadingExternalFile()), new File(getDownloadedFile(apkUpdateInfo).getAbsolutePath()));
    }

    @Nullable
    public String getDownloadedFileHash(ApkUpdateInfo apkUpdateInfo, String str) {
        Preconditions.checkArgument(apkUpdateInfo.getExtras().hasKey(ApkUpdateInfoContract.EXTRA_DOWNLOADED_EXTERNAL_FILE));
        String downloadedExternalFile = apkUpdateInfo.getExtras().getDownloadedExternalFile();
        File file = new File(downloadedExternalFile);
        if (!file.exists() || !file.isFile()) {
            BLog.e(TAG, "Invalid path supplied for file md5: %s", downloadedExternalFile);
            return null;
        }
        try {
            return ((CryptoMethods) FbInjector.lazyInstance(3, CommonModule.UL_id._UL__ULSEP_com_oculus_appmanager_installer_common_CryptoMethods_ULSEP_BINDING_ID, this._UL_mInjectionContext)).getFileHash(file, str);
        } catch (Exception e) {
            BLog.e(TAG, e, "Exception occurred while getting md5 of downloaded file");
            return null;
        }
    }

    public String applyPatchIfNecessary(ApkUpdateInfo apkUpdateInfo) throws IOException {
        String str;
        Preconditions.checkArgument(apkUpdateInfo.getExtras().hasKey(ApkUpdateInfoContract.EXTRA_DOWNLOADED_EXTERNAL_FILE));
        String downloadedExternalFile = apkUpdateInfo.getExtras().getDownloadedExternalFile();
        ApkUpdateInfoContract.UpdateType updateType = apkUpdateInfo.updateType;
        if (!updateType.isPatchUpdate()) {
            return downloadedExternalFile;
        }
        long now = ((Clock) FbInjector.lazyInstance(5, TimeModule.UL_id._UL__ULSEP_com_oculus_time_Clock_ULSEP_BINDING_ID, this._UL_mInjectionContext)).now();
        apkUpdateInfo.edit().putPatchingStartTimeMs(now).save();
        String absolutePath = getPatchedFile(apkUpdateInfo).getAbsolutePath();
        if (updateType.isApk()) {
            str = getInstalledApkPath(apkUpdateInfo);
        } else if (updateType.isObb()) {
            str = getInstalledObbPath(apkUpdateInfo);
        } else if (updateType.isAsset()) {
            str = getFinalAssetPath(apkUpdateInfo);
        } else {
            throw new IllegalArgumentException("Invalid update type supplied: " + apkUpdateInfo.updateType.name());
        }
        ensureFileExistsOrThrow(str);
        this.mPatcherLazy.get().patchFile(str, absolutePath, downloadedExternalFile);
        ensureFileExistsOrThrow(absolutePath);
        removeFileWithReason(downloadedExternalFile, "Remove patch after applying");
        apkUpdateInfo.edit().putPatchingDurationMs(((Clock) FbInjector.lazyInstance(5, TimeModule.UL_id._UL__ULSEP_com_oculus_time_Clock_ULSEP_BINDING_ID, this._UL_mInjectionContext)).now() - now).save();
        return absolutePath;
    }

    private String getInstalledObbPath(ApkUpdateInfo apkUpdateInfo) {
        Preconditions.checkArgument(!TextUtils.isEmpty(apkUpdateInfo.getPackageName()));
        try {
            return getFinalObbPath(apkUpdateInfo.getPackageName(), (long) ((PackageManager) FbInjector.lazyInstance(1, AndroidModule.UL_id._UL__ULSEP_android_content_pm_PackageManager_ULSEP_BINDING_ID, this._UL_mInjectionContext)).getPackageInfo(apkUpdateInfo.getPackageName(), 0).versionCode);
        } catch (Exception e) {
            throw new RuntimeException("Unable to get currently installed OBB", e);
        }
    }

    private String getInstalledApkPath(ApkUpdateInfo apkUpdateInfo) {
        Preconditions.checkArgument(!TextUtils.isEmpty(apkUpdateInfo.getPackageName()));
        try {
            return ((PackageManager) FbInjector.lazyInstance(1, AndroidModule.UL_id._UL__ULSEP_android_content_pm_PackageManager_ULSEP_BINDING_ID, this._UL_mInjectionContext)).getPackageInfo(apkUpdateInfo.getPackageName(), 0).applicationInfo.sourceDir;
        } catch (Exception e) {
            throw new RuntimeException("Unable to get currently installed APK", e);
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:22:0x009f  */
    /* JADX WARNING: Removed duplicated region for block: B:23:0x00a4 A[SYNTHETIC, Splitter:B:23:0x00a4] */
    /* JADX WARNING: Removed duplicated region for block: B:30:0x00e4  */
    /* JADX WARNING: Removed duplicated region for block: B:39:0x0125  */
    @javax.annotation.Nullable
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public java.lang.String moveApkToInternalStorage(com.oculus.appmanager.info.ApkUpdateInfo r11, boolean r12) throws java.io.IOException {
        /*
        // Method dump skipped, instructions count: 410
        */
        throw new UnsupportedOperationException("Method not decompiled: com.oculus.appmanager.installer.common.InstallerFileUtils.moveApkToInternalStorage(com.oculus.appmanager.info.ApkUpdateInfo, boolean):java.lang.String");
    }

    public boolean removeFileWithReason(String str, String str2) {
        return removeFileWithReason(new File(str), str2);
    }

    @Nullable
    public File getFile(String str) {
        if (str == null) {
            return null;
        }
        return new File(str);
    }

    public long getFileSize(String str) {
        File file = new File(str);
        if (file.exists()) {
            return file.length();
        }
        return -1;
    }
}
