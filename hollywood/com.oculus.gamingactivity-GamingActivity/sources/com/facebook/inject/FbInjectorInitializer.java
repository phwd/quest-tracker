package com.facebook.inject;

import com.facebook.debug.tracer.Tracer;
import com.facebook.inject.testing.OverridesBindings;
import com.facebook.ultralight.UL;
import com.google.common.base.Throwables;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import com.google.inject.Key;
import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.inject.Provider;

/* access modifiers changed from: package-private */
public class FbInjectorInitializer {
    private final Map<Integer, Binding> mBindingMap;
    private final Map<Key, ComponentBinding> mComponentBindingMap;
    private final FbInjector mFbInjector;
    private final boolean mIsDebugMode;
    private final List<? extends PrivateModule> mModules;
    private final Set<Class<?>> mModulesInstalled;
    private final Map<Key, MultiBinder> mMultiBindings;
    private final Map<Class<? extends Annotation>, Scope> mScopeMap;

    public FbInjectorInitializer(FbInjector fbInjector, List<? extends PrivateModule> modules, boolean isDebugMode) {
        this.mBindingMap = Maps.newHashMap();
        this.mComponentBindingMap = Maps.newHashMap();
        this.mModulesInstalled = new HashSet();
        this.mScopeMap = Maps.newLinkedHashMap();
        this.mMultiBindings = Maps.newHashMap();
        this.mFbInjector = fbInjector;
        this.mModules = modules;
        this.mIsDebugMode = isDebugMode;
    }

    public FbInjectorInitializer(FbInjector fbInjector, List<? extends PrivateModule> modules, boolean isDebugMode, Map<Integer, Binding> bindingMap, Map<Class<? extends Annotation>, Scope> scopeMap, Map<Key, ComponentBinding> componentBindingMap, Set<Class<?>> modulesInstalled, Map<Key, MultiBinder> multiBindings) {
        this(fbInjector, modules, isDebugMode);
        this.mBindingMap.putAll(bindingMap);
        this.mComponentBindingMap.putAll(componentBindingMap);
        this.mScopeMap.putAll(scopeMap);
        this.mModulesInstalled.addAll(modulesInstalled);
        this.mMultiBindings.putAll(multiBindings);
    }

    /* access modifiers changed from: package-private */
    public static class Result {
        final Map<Integer, Binding> bindingMap;
        final Map<Key, ComponentBinding> componentBindingMap;
        final Set<Class<?>> modulesInstalled;
        final Map<Key, MultiBinder> multiBindings;
        final Map<Class<? extends Annotation>, Scope> scopeMap;

        Result(Map<Integer, Binding> bindingMap2, Map<Class<? extends Annotation>, Scope> scopeMap2, Map<Key, ComponentBinding> componentBindingMap2, Set<Class<?>> modulesInstalled2, Map<Key, MultiBinder> multiBindings2) {
            this.bindingMap = bindingMap2;
            this.scopeMap = scopeMap2;
            this.componentBindingMap = componentBindingMap2;
            this.modulesInstalled = modulesInstalled2;
            this.multiBindings = multiBindings2;
        }
    }

    public Result init() {
        return runInit(false);
    }

    public Result update() {
        return runInit(true);
    }

    private Result runInit(boolean isUpdate) {
        Tracer.startTracer("FbInjectorImpl.init#modules");
        if (!isUpdate) {
            try {
                installSpecialModule(new UL.InitModule());
            } catch (Throwable th) {
                Tracer.stopTracer();
                throw th;
            }
        }
        if (!UL.USE_STATIC_DI) {
            for (PrivateModule module : this.mModules) {
                this.mModulesInstalled.add(module.getClass());
                installPrivateModule(module);
            }
        }
        Tracer.stopTracer();
        if (!UL.USE_STATIC_DI) {
            initializeMultiBindings();
        }
        return new Result(this.mBindingMap, this.mScopeMap, this.mComponentBindingMap, this.mModulesInstalled, this.mMultiBindings);
    }

    private void installSpecialModule(SpecialModule module) {
        Binder binder = new BinderImpl(this.mFbInjector, module.getClass());
        module.configure(binder);
        installModule(binder, module.getClass());
        this.mModulesInstalled.add(module.getClass());
    }

    private void installLegacyModule(Class<?> module) {
        Binder binder = new BinderImpl(this.mFbInjector, module);
        if (OverridesBindings.class.isAssignableFrom(module) || (module.getAnnotation(InjectorModule.class) == null && module.getAnnotation(GeneratedInjectorModule.class) == null)) {
            invokeConfigure(newInstanceOfModule(module), binder);
        } else {
            invokeAutoGeneratedBindings(module, binder);
        }
        installModule(binder, module);
    }

    private void installPrivateModule(PrivateModule module) {
        Binder binder = new BinderImpl(this.mFbInjector, module.getClass());
        invokeConfigure(module, binder);
        installModule(binder, module.getClass());
    }

    private void invokeAutoGeneratedBindings(Class module, Binder binder) {
        try {
            Method configure = Class.forName(module.getName() + "$AutoGeneratedBindingsFor" + module.getSimpleName().toString()).getDeclaredMethod("bind", Binder.class);
            configure.setAccessible(true);
            configure.invoke(null, binder);
        } catch (NoSuchMethodException e) {
            throw Throwables.propagate(e);
        } catch (IllegalAccessException e2) {
            throw Throwables.propagate(e2);
        } catch (InvocationTargetException e3) {
            Throwables.propagateIfInstanceOf(e3.getCause(), RuntimeException.class);
        } catch (ClassNotFoundException e4) {
            throw Throwables.propagate(e4);
        }
    }

    private void invokeConfigure(Object module, Binder binder) {
        try {
            Field binderField = AbstractModule.class.getDeclaredField("mBinder");
            binderField.setAccessible(true);
            binderField.set(module, binder);
            Method configure = module.getClass().getDeclaredMethod("configure", new Class[0]);
            configure.setAccessible(true);
            configure.invoke(module, new Object[0]);
        } catch (NoSuchFieldException | NoSuchMethodException e) {
        } catch (IllegalAccessException e2) {
            throw Throwables.propagate(e2);
        } catch (InvocationTargetException e3) {
            Throwables.propagateIfInstanceOf(e3.getCause(), RuntimeException.class);
        }
    }

    private void installModule(Binder binder, Class<?> module) {
        this.mScopeMap.putAll(binder.getScopes());
        for (Class<?> requiredModuleClass : binder.getRequiredModules()) {
            if (!this.mModulesInstalled.contains(requiredModuleClass)) {
                this.mModulesInstalled.add(requiredModuleClass);
                installLegacyModule(requiredModuleClass);
            }
        }
        Iterator<Binding> it = binder.getBindings().iterator();
        while (it.hasNext()) {
            addSingleBinding(this.mFbInjector, module, it.next(), binder.getRequiredModules());
        }
        if (!UL.USE_STATIC_DI) {
            for (Scope scope : binder.getScopes().values()) {
                Binding binding = new Binding();
                binding.setModule(module.getClass());
                binding.setKey(Key.get((Class) scope.getClass()));
                binding.setProvider(new InstanceProvider(scope));
                addSingleBinding(this.mFbInjector, module, binding, binder.getRequiredModules());
            }
        }
        for (ComponentBinding binding2 : binder.getComponentBindings()) {
            ComponentProvider provider = binding2.getProvider();
            if (provider instanceof ComponentProviderWithInjector) {
                ((ComponentProviderWithInjector) provider).setInjector(this.mFbInjector);
            }
            this.mComponentBindingMap.put(binding2.getKey(), binding2);
        }
        for (Key key : Sets.union(binder.getMultiBindingDeclarations(), binder.getMultiBindings().keySet())) {
            if (this.mMultiBindings.get(key) == null) {
                this.mMultiBindings.put(key, new MultiBinder(this.mFbInjector, key));
            }
        }
        for (Map.Entry<Key, MultiBinding> entry : binder.getMultiBindings().entrySet()) {
            this.mMultiBindings.get(entry.getKey()).addAll(entry.getValue().getValues());
        }
    }

    /* JADX DEBUG: Multi-variable search result rejected for r12v0, resolved type: com.facebook.inject.Binding<T> */
    /* JADX WARN: Multi-variable type inference failed */
    private <T> void addSingleBinding(FbInjector moduleInjector, Class<?> module, Binding<T> binding, List<Class<?>> requiredModules) {
        Key<T> key = binding.getKey();
        int ultralightKey = UL.id.dynamicId(key);
        Provider<T> provider = binding.getProvider();
        binding.setOriginalProvider(provider);
        Binding oldBinding = this.mBindingMap.get(Integer.valueOf(ultralightKey));
        if (oldBinding == null || !canOverrideBindings(oldBinding.getDeclaringModule()) || canOverrideBindings(module)) {
            if (oldBinding != null && !canOverrideBindings(module)) {
                if (!oldBinding.isDefaultBinding()) {
                    throw new IllegalArgumentException(String.format("Module %s illegally overriding binding for %s from module %s. Either require module %s(base module) from %s or provide %s as a default binding so it can be overridden in module %s(top module) .", binding.getDeclaringModule().getCanonicalName(), oldBinding.getKey().toString(), oldBinding.getDeclaringModule().getCanonicalName(), oldBinding.getDeclaringModule().getCanonicalName(), binding.getDeclaringModule().getCanonicalName(), oldBinding.getKey().toString(), binding.getDeclaringModule().getCanonicalName()));
                } else if (!oldBinding.isDefaultBinding() && !oldBinding.getDeclaringModule().equals(binding.getDeclaringModule()) && !requiredModules.contains(oldBinding.getDeclaringModule())) {
                    throw new IllegalArgumentException(String.format("Module %s is overriding binding for %s from module %s, but does not require that module. Add %s(base module) in the dependency list of %s.", binding.getDeclaringModule().getCanonicalName(), oldBinding.getKey().toString(), oldBinding.getDeclaringModule().getCanonicalName(), oldBinding.getDeclaringModule().getCanonicalName(), binding.getDeclaringModule().getCanonicalName()));
                }
            }
            if (provider instanceof ProviderWithInjector) {
                ((ProviderWithInjector) provider).setInjector(moduleInjector);
            }
            if (binding.getScope() != null) {
                provider = getScope(binding.getScope()).scope(key, provider);
                if (provider instanceof ProviderWithInjector) {
                    ((ProviderWithInjector) provider).setInjector(moduleInjector);
                }
            }
            binding.setProvider(provider);
            this.mBindingMap.put(Integer.valueOf(ultralightKey), binding);
        }
    }

    private Object newInstanceOfModule(Class<?> moduleClass) {
        try {
            Constructor<?> constructor = moduleClass.getConstructor(new Class[0]);
            constructor.setAccessible(true);
            return constructor.newInstance(new Object[0]);
        } catch (NoSuchMethodException e) {
            throw new RuntimeException("Failed to find public default constructor for " + moduleClass, e);
        } catch (InvocationTargetException e2) {
            throw new RuntimeException("Failed to invoke constructor for " + moduleClass, e2);
        } catch (InstantiationException e3) {
            throw new RuntimeException("Failed to instantiate " + moduleClass, e3);
        } catch (IllegalAccessException e4) {
            throw new RuntimeException("Failed to access constructor for " + moduleClass, e4);
        }
    }

    private void initializeMultiBindings() {
        Tracer.startTracer("FbInjectorImpl.init#multiBinding");
        try {
            for (MultiBinder<?> binder : this.mMultiBindings.values()) {
                Binding binding = new Binding();
                binding.setKey(binder.getBoundKey());
                binding.setProvider(binder.getProvider());
                binding.setOriginalProvider(binder.getProvider());
                this.mBindingMap.put(Integer.valueOf(UL.id.dynamicId(binder.getBoundKey())), binding);
            }
        } finally {
            Tracer.stopTracer();
        }
    }

    private Scope getScope(Class<? extends Annotation> scopeAnnotation) {
        Scope scope = this.mScopeMap.get(scopeAnnotation);
        if (scope != null) {
            return scope;
        }
        throw new ProvisioningException("No scope registered for " + scopeAnnotation);
    }

    private static boolean canOverrideBindings(Class<?> module) {
        return OverridesBindings.class.isAssignableFrom(module) || UL.InitModule.class.isAssignableFrom(module);
    }
}
